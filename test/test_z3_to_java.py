import sys
import pytest
import os

import z3

curr_dir = os.getcwd()
sys.path.insert(1, os.path.join(curr_dir, "src"))

from src.util.z3_to_java import z3_to_java
from src.jbse.symbol import *
from src.java.type import *

NUM_MODELS = 10

symmap = {
    (("{ROOT}", "mybool"),): JBSESymbolValue(0, JavaTypeBoolean()),
    (("{ROOT}", "mybyte"),): JBSESymbolValue(1, JavaTypeByte()),
    (("{ROOT}", "mychar"),): JBSESymbolValue(2, JavaTypeChar()),
    (("{ROOT}", "myshort"),): JBSESymbolValue(3, JavaTypeShort()),
    (("{ROOT}", "myint"),): JBSESymbolValue(4, JavaTypeInt()),
    (("{ROOT}", "mylong"),): JBSESymbolValue(5, JavaTypeLong()),
    (("{ROOT}", "myfloat"),): JBSESymbolValue(6, JavaTypeFloat()),
    (("{ROOT}", "mydouble"),): JBSESymbolValue(7, JavaTypeDouble()),
}


def test_single_var():
    result = z3_to_java(z3.And(z3.Bool("{V0}")), symmap)
    assert result == "(mybool)"


def char2int():
    # (int)(mychar)
    result = z3_to_java(
        z3.SignExt(16, z3.BitVec("{V2}", 16)),
        symmap,
    )
    assert result == "(int)(mychar)"


def test_int2bool():
    # (bool)(myint)
    result = z3_to_java(
        z3.If(
            z3.BitVec("{V4}", 32) == z3.BitVecVal(0, 32),
            z3.BitVecVal(0, 1),
            z3.BitVecVal(1, 1),
        ),
        symmap,
    )
    assert result == "(bool)(myint)"


def test_int2char():
    # (char)(myint)
    result = z3_to_java(
        z3.Extract(15, 0, z3.BitVec("{V4}", 32)),
        symmap,
    )
    assert result == "(char)(myint)"


def test_double2int():
    # (int)(0.3 + mydouble)
    result = z3_to_java(
        z3.Int2BV(z3.ToInt(z3.RealVal(0.3) + (z3.Real("{V7}"))), 32),
        symmap,
    )
    assert result == "(int)((0.3d+mydouble))"


def test_int_add():
    # myint + 3
    result = z3_to_java(
        z3.BitVec("{V4}", 32) + z3.BitVecVal(-1, 32),
        symmap,
    )
    assert result == "(myint+-1)"


def test_complex():
    # The following z3 ref is generated by the following JBSE output:
    #     (WIDEN-ID((NARROW-DI((0.3d) + ({V7}))) + (3))) + (WIDEN-ID((NARROW-DI((0.3d) + ({V7}))) + (WIDEN-CI({V2})) + (40))) >= (0.0d)

    # The corresponding Java code is:
    #     (double)((int)(0.3d + mydouble) + (int)(3.0d)) + (double)((int)(0.3d + mydouble) + (int)(mychar + '(')) >= 0.0d
    # where x: {V6} is a float and c: {V2} is a char.

    # (double)((int)(0.3d + x))
    result = z3_to_java(
        (
            z3.ToReal(
                z3.BV2Int(
                    (z3.Int2BV(z3.ToInt(z3.RealVal(0.3) + (z3.Real("{V7}"))), 32))
                    + z3.BitVecVal(3, 32),
                    is_signed=True,
                )
            )
        )
        + (
            z3.ToReal(
                z3.BV2Int(
                    (z3.Int2BV(z3.ToInt(z3.RealVal(0.3) + (z3.Real("{V7}"))), 32))
                    + (z3.ZeroExt(16, z3.BitVec("{V2}", 16)))
                    + z3.BitVecVal(40, 32),
                    is_signed=True,
                )
            )
        )
        >= z3.RealVal(0.0),
        symmap,
    )
    assert (
        result
        == "(0.0d<=((double)(((int)((0.3d+mydouble))+3))+(double)((((int)((0.3d+mydouble))+(int)(mychar))+40))))"
    )


def test_chained_add():
    # 1 + myint + 3
    result = z3_to_java(
        z3.BitVecVal(1, 32) + z3.BitVec("{V4}", 32) + z3.BitVecVal(3, 32),
        symmap,
    )
    assert result == "((1+myint)+3)"
